#pragma config(Sensor, in2,    potLeft,        sensorPotentiometer)
#pragma config(Sensor, in3,    potRight,       sensorPotentiometer)
#pragma config(Motor,  port1,           intakeMotor,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRightArm,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           bottomRightArm, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeftArm,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           bottomLeftArm, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
/*
string beltDirection; //forward backward stop
string wheelRotation; // left right stop
string moveDirection; //forward backward left right stop
string armDirection; //moves arm up or down

void intake()
{
if(beltDirection == "forward")
{
motor[port1] = -100;

}

if(beltDirection == "backward")
{
motor[port1] = 100;

}
if(beltDirection == "stop")
{
motor[port1] = 0;

}

}



void movement() //forwards, backwards, left and right (strafing)
{


if(moveDirection == "forward")
{
motor[port6] = 100;
motor[port7] = 100;
motor[port8] = 100;
motor[port9] = 100;

}

if(moveDirection == "backward")
{
motor[port6] = -100;
motor[port7] = -100;
motor[port8] = -100;
motor[port9] = -100;
}

if(moveDirection == "left")
{
motor[port6] = 100;
motor[port7] = -100;
motor[port8] = 100;
motor[port9] = -100;
}

if(moveDirection == "right")
{
motor[port6] = -100;
motor[port7] = 100;
motor[port8] = -100;
motor[port9] = 100;
}

if(moveDirection == "stop")
{
motor[port6] = 0;
motor[port7] = 0;
motor[port8] = 0;
motor[port9] = 0;
}




}

void rotation()
{


if(wheelRotation == "left")
{


motor[port6] = 100;
motor[port7] = 100;
motor[port8] = -100;
motor[port9] = -100;

}

if(wheelRotation == "right")
{
motor[port6] = -100;
motor[port7] = -100;
motor[port8] =  100;
motor[port9] =  100;
}
if(wheelRotation == "stop")
{
motor[port6] =  0;
motor[port7] =  0;
motor[port8] =  0;
motor[port9] =  0;

}


}


void armtasks()
{
if(armDirection == "up")
{
motor[port2] = -127;
motor[port3] = -127;
motor[port4] = -127;
motor[port5] = -127;

}
if(armDirection == "down")
{
motor[port2] =  100;
motor[port3] =  100;
motor[port4] =  100;
motor[port5] =  100;

}


if(armDirection == "stop")
{
motor[port2] = 0;
motor[port3] = 0;
motor[port4] = 0;
motor[port5] = 0;

}

}
*/
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	nMotorEncoder[port6] = 0;
	nMotorEncoder[port7] = 0;
	nMotorEncoder[port8] = 0;
	nMotorEncoder[port9] = 0;


	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// The main task for the autonomous is to pick up a cube (we start with 1 cube preloaded)
  //and drop both the cubes on a pillar for 4 points.
	//moves forward
	motor[port6] = 127;
	motor[port7] = 127;
	motor[port8] = 127;
	motor[port9] = 127;
	wait1Msec(600);
	//stops robot
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	wait1Msec(100); //wait 100 ms before moving on
	//picks up cube
	motor[port1] = 127;
	motor[port2] = 127;
	wait1Msec(2600);
	// stops the arm
	motor[port1] = 0;
	motor[port2] = 0;


	//rotates
	motor[port6] =  -127;
	motor[port7] =  -127;
	motor[port8] =  127;
	motor[port9] =  127;
	wait1Msec(1320);
	//stops robot
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	//moves forward
	motor[port6] = 127;
	motor[port7] = 127;
	motor[port8] =  127;
	motor[port9] =  127;
	wait1Msec(600);




	//stops robot
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	wait1Msec(100);
	//lifts arm up
	motor[port2] = -100;
	motor[port3] = -100;
	motor[port4] = -100;
	motor[port5] = -100;
	wait1Msec(1125);
	//stops arm
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
  wait1Msec(100);
  //drops off cubes
	motor[port2] = -127;
	motor[port1] = -127;
	wait1Msec(5000);
	//stops intake
	motor[port1] = 0;
	motor[port1] = 0;
	wait1Msec(500);
	//moves away from pole
	motor[port6] = -127;
	motor[port7] = -127;
	motor[port8] = -127;
	motor[port9] = -127;
	wait1Msec(600);










	/*

	nMotorEncoder[port6] = 0;
	moveDirection = "forward"; //sets diretion of movement() to go forward

	while(nMotorEncoder[port6] < 400 && moveDirection == "forward")// go forward till encoder < 450
	{
	movement();
	}

	moveDirection = "stop"; //sets movement() to stop

	movement();

	beltDirection = "backward"; //sets intake motor to go backwards

	if(beltDirection == "backward") //pick up starting cube
	{
	intake();
	wait1Msec(1700);

	}

	beltDirection = "stop"; // stop the belt
	intake();



	nMotorEncoder[port6] = 0;
	nMotorEncoder[port7] = 0;
	nMotorEncoder[port8] = 0;
	nMotorEncoder[port9] = 0;

	wheelRotation = "right"; //sets rotation to go right


	while(nMotorEncoder[port9] < 1300) //rotates right till motor encoder reaches 1300
	{
	rotation();
	}

	wheelRotation = "stop";
	if(nMotorEncoder[port9] >= 1300) // stop the rotation

	{

	rotation();

	}

	nMotorEncoder[port6] = 0;
	moveDirection = "forward"; //sets diretion of movement() to go forward

	while(nMotorEncoder[port6] < 300 && moveDirection == "forward")// go forward till encoder < 450
	{
	movement();
	}

	moveDirection = "stop"; //sets movement() to stop

	movement();

	moveDirection = "forward"; //sets diretion of movement() to go forward
	while(nMotorEncoder[port6] > -300 && moveDirection == "backward")// go forward till encoder < 450
	{
	movement();
	}

	moveDirection = "stop"; //sets movement() to stop

	movement();








	armDirection = "up"; // sets arm to go up
	while(SensorValue[potLeft] <= 2900 && SensorValue[potRight] <= 1700) //values of lowest post
	{
	armtasks();
	}

	armDirection = "stop";


	armtasks();



	wait1Msec(300);

	nMotorEncoder[port6] = 0;
	moveDirection = "forward"; //sets diretion of movement() to go forward

	while(nMotorEncoder[port6] < 200 && moveDirection == "forward")// go forward until encoder < 100
	{
	movement();
	}

	moveDirection = "stop"; //sets movement() to stop

	movement();






	beltDirection = "forward";

	if(beltDirection == "forward") //drop cube
	{
	intake();
	wait1Msec(4000);

	}

	beltDirection = "stop"; // stop the belt
	intake();

	wait1Msec(300);



	armDirection = "down"; // sets arm to go down

	while(SensorValue[potLeft] >= 2900 && SensorValue[potRight] >= 1700) //values of lowest post
	{
	armtasks();
	}

	armDirection = "stop";

	armtasks();

	nMotorEncoder[port6] = 0;
	moveDirection = "backward"; //sets diretion of movement() to go backward

	while(nMotorEncoder[port6] > -350 && moveDirection == "backward")// go forward till encoder < 100
	{
	movement();
	}

	moveDirection = "stop"; //sets movement() to stop

	movement();
	*/




}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol() {
	//Joystick variables
	int chnl1 = 0, chnl4 = 0, chnl3 = 0, threshold = 10;
	//Arm presets variables
	int lowPostLeft = 2613, lowPostRight = 1497, medPostLeft = 3600, medPostRight = 2300, highPostRight = 3072, leftStartPos = 1990, rightStartPos = 925;

	// User control code here, inside the loop
	while (true) {
		//Driver control with controller 1
		//Create deadzone for Channel 1
		if(abs(vexRT[Ch1]) > threshold) {
			chnl1 = vexRT[Ch1];
		}
		else {
			chnl1 = 0;
		}
		//Create deadzone for Channel 4
		if(abs(vexRT[Ch4]) > threshold) {
			chnl4 = vexRT[Ch4];
		}
		else {
			chnl4 = 0;
		}
		//Create deadzone for Channel 3
		if(abs(vexRT[Ch3]) > threshold) {
			chnl3 = vexRT[Ch3];
		}
		else {
			chnl3 = 0;
		}

		//Joystick control for driver
		motor[frontRight] = chnl3 - chnl1 - chnl4;
		motor[backRight] = chnl3 - chnl1 + chnl4;
		motor[backLeft] = chnl3 + chnl1 - chnl4;
		motor[frontLeft] = chnl3 + chnl1 + chnl4;

		//Arm Control with controller 2
		//Arm up and down control
		motor[topLeftArm] = -vexRT[Ch3Xmtr2];
		motor[bottomLeftArm] = -vexRT[Ch3Xmtr2];
		motor[topRightArm] = -vexRT[Ch3Xmtr2];
		motor[bottomRightArm] = -vexRT[Ch3Xmtr2];

		//Arm presets
		//Preset for low post up
		//Check if left button 7 is pressed
		if(vexRT[Btn7LXmtr2] == 1 || vexRT[Btn8LXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the low post potentiometers
			while(SensorValue[potLeft] < lowPostLeft && SensorValue[potRight] < lowPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for med post up
		//Check if up button 7 is pressed
		if(vexRT[Btn7UXmtr2] == 1 || vexRT[Btn8UXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the med post potentiometers
			while(SensorValue[potLeft] < medPostLeft && SensorValue[potRight] < medPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for high post up
		//Check if right button 7 is pressed
		if(vexRT[Btn7RXmtr2] == 1 || vexRT[Btn8RXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the high post potentiometers
			while(SensorValue[potRight] < highPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for returning arm to start position
		//Check if down button 7 or 8 are pressed
		if(vexRT[Btn7DXmtr2] == 1 || vexRT[Btn8DXmtr2] == 1) {
			//Lower arm while current potentiometer values are less than the starting values of the potentiometers
			while(SensorValue[potLeft] < leftStartPos && SensorValue[potRight] < rightStartPos) {
				motor[topLeftArm] = 127;
				motor[bottomLeftArm] = 127;
				motor[topRightArm] = 127;
				motor[bottomRightArm] = 127;
			}
		}
		//Intake motor open and close control
		if(vexRT[Btn5UXmtr2] == 1) {
			motor[intakeMotor] = -127;
		}
		else if(vexRT[Btn6UXmtr2] == 1) {
			motor[intakeMotor] = 127;
		}
		else {
			motor[intakeMotor] = 0;
		}

		if(vexRT[Btn5DXmtr2] == 1) {
			motor[topLeftArm] = -127;
			motor[bottomLeftArm] = -127;
		}
		if(vexRT[Btn6DXmtr2] == 1) {
			motor[topRightArm] = -127;
			motor[bottomRightArm] = -127;
		}

		//UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}
