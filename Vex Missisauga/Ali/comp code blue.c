#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    potLeft,        sensorPotentiometer)
#pragma config(Sensor, in3,    potRight,       sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intakeMotor,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRightArm,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           bottomRightArm, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topLeftArm,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           bottomLeftArm, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!




/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	nMotorEncoder[port6] = 0;
	nMotorEncoder[port7] = 0;
	nMotorEncoder[port8] = 0;
	nMotorEncoder[port9] = 0;


	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// The main task for the autonomous is to pick up a cube (we start with 1 cube preloaded)
	//and drop both the cubes on a pillar for 4 points.

	// while motorencoder port6 <400
	while(nMotorEncoder[port6] < 400){
	// move forward all motors
		motor[port6] = 127;
		motor[port7] = 127;
		motor[port8] = 127;
		motor[port9] = 127;
	}
	//stops robot
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	//wait 100 ms before moving on
	wait1Msec(100);

	//intake motor backwards
	motor[port1] = 127;
	wait1Msec(2600);
	//stops intake motor
	motor[port1] = 0;

	//resets all motor encoders to 0 except port 6
	nMotorEncoder[port6] = 0;
	nMotorEncoder[port7] = 0;
	nMotorEncoder[port8] = 0;
	nMotorEncoder[port9] = 0;
	//while motor encoder port 9 < 1300
	while(nMotorEncoder[port9] < 1300){
		//rotates right using port9 motor encoder
		motor[port6] = 127;
		motor[port7] = 127;
		motor[port8] =  -127;
		motor[port9] =  -127;
	}
	// while motor encoder port 9 > 1300

		//stops the robot
		motor[port6] =  0;
		motor[port7] =  0;
		motor[port8] =  0;
		motor[port9] =  0;

	//while motor encoder is less than 400
	while(nMotorEncoder[port8] < 400){
		//forward all motors
		motor[port6] = 127;
		motor[port7] = 127;
		motor[port8] = 127;
		motor[port9] = 127;
	}
	//stops the robot
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	wait1Msec(100);
	//extends arm up
	motor[port2] = -100;
	motor[port3] = -100;
	motor[port4] = -100;
	motor[port5] = -100;
	wait1Msec(1125);
	//stops arm
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	wait1Msec(100);
	//intake motor drops off cubes
	motor[port1] = -127;
	wait1Msec(5000);
	//stops intake motor
	motor[port1] = 0;
	wait1Msec(100);
	// move backwards away from cubes
	motor[port6] =-127; // move backwards away from cubes
	motor[port7] =-127;
	motor[port8] =-127;
	motor[port9] =-127;






}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol() {
	//Joystick variables
	int chnl1 = 0, chnl4 = 0, chnl3 = 0, threshold = 10;
	//Arm presets variables
	int lowPostLeft = 2613, lowPostRight = 1497, medPostLeft = 3600, medPostRight = 2300, highPostRight = 3072, leftStartPos = 1990, rightStartPos = 925;

	// User control code here, inside the loop
	while (true) {
		//Driver control with controller 1
		//Create deadzone for Channel 1
		if(abs(vexRT[Ch1]) > threshold) {
			chnl1 = vexRT[Ch1];
		}
		else {
			chnl1 = 0;
		}
		//Create deadzone for Channel 4
		if(abs(vexRT[Ch4]) > threshold) {
			chnl4 = vexRT[Ch4];
		}
		else {
			chnl4 = 0;
		}
		//Create deadzone for Channel 3
		if(abs(vexRT[Ch3]) > threshold) {
			chnl3 = vexRT[Ch3];
		}
		else {
			chnl3 = 0;
		}

		//Joystick control for driver
		motor[frontRight] = chnl3 - chnl1 - chnl4;
		motor[backRight] = chnl3 - chnl1 + chnl4;
		motor[backLeft] = chnl3 + chnl1 - chnl4;
		motor[frontLeft] = chnl3 + chnl1 + chnl4;

		//Arm Control with controller 2
		//Arm up and down control
		motor[topLeftArm] = -vexRT[Ch3Xmtr2];
		motor[bottomLeftArm] = -vexRT[Ch3Xmtr2];
		motor[topRightArm] = -vexRT[Ch3Xmtr2];
		motor[bottomRightArm] = -vexRT[Ch3Xmtr2];

		//Arm presets
		//Preset for low post up
		//Check if left button 7 is pressed
		if(vexRT[Btn7LXmtr2] == 1 || vexRT[Btn8LXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the low post potentiometers
			while(SensorValue[potLeft] < lowPostLeft && SensorValue[potRight] < lowPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for med post up
		//Check if up button 7 is pressed
		if(vexRT[Btn7UXmtr2] == 1 || vexRT[Btn8UXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the med post potentiometers
			while(SensorValue[potLeft] < medPostLeft && SensorValue[potRight] < medPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for high post up
		//Check if right button 7 is pressed
		if(vexRT[Btn7RXmtr2] == 1 || vexRT[Btn8RXmtr2] == 1) {
			//Raise arm while current potentiometer values are less than the high post potentiometers
			while(SensorValue[potRight] < highPostRight) {
				motor[topLeftArm] = -127;
				motor[bottomLeftArm] = -127;
				motor[topRightArm] = -127;
				motor[bottomRightArm] = -127;
			}
		}
		//Preset for returning arm to start position
		//Check if down button 7 or 8 are pressed
		if(vexRT[Btn7DXmtr2] == 1 || vexRT[Btn8DXmtr2] == 1) {
			//Lower arm while current potentiometer values are less than the starting values of the potentiometers
			while(SensorValue[potLeft] < leftStartPos && SensorValue[potRight] < rightStartPos) {
				motor[topLeftArm] = 127;
				motor[bottomLeftArm] = 127;
				motor[topRightArm] = 127;
				motor[bottomRightArm] = 127;
			}
		}
		//Intake motor open and close control
		if(vexRT[Btn5UXmtr2] == 1) {
			motor[intakeMotor] = -127;
		}
		else if(vexRT[Btn6UXmtr2] == 1) {
			motor[intakeMotor] = 127;
		}
		else {
			motor[intakeMotor] = 0;
		}

		if(vexRT[Btn5DXmtr2] == 1) {
			motor[topLeftArm] = -127;
			motor[bottomLeftArm] = -127;
		}
		if(vexRT[Btn6DXmtr2] == 1) {
			motor[topRightArm] = -127;
			motor[bottomRightArm] = -127;
		}

		//UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}
