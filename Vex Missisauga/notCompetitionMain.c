#pragma config(Sensor, in1,    potRight,       sensorPotentiometer)
#pragma config(Sensor, in2,    potLeft,        sensorPotentiometer)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           bottomLeftArm, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           bottomRightArm, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           topLeftArm,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topRightArm,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/// PUT THESE INTO THE WIZARD --Gary

#define MAX(x,y) ((x)<(y) ? (y) : (x))
#define MIN(x,y) ((x)>(y) ? (y) : (x))

//Motor variables
//float driveMotor[4] = {motor[frontRight], motor[backRight], motor[backLeft], motor[frontLeft]};
//float armIntakeMotor[4] = {motor[topRightArm], motor[bottomRightArm], motor[topLeftArm], motor[bottomLeftArm]};
//Joystick variables
int chnl1 = 0, chnl3 = 0, threshold = 10;
//Drive variables
int fullPower = 127;
// Encoder values for the arms in the previous tick
int prevLeftArm = 806;
int prevRightArm = 248;
int leftArmBase;
int rightArmBase;
bool automation = false;
const float armForceAdjustConst =  1.0/100;

// How much we should change the force we are applying based on
// the potentiometer diffs
float armForceAdjust(int prev, int cur){
	return (prev-cur)*armForceAdjustConst;
}

float leftArmForce=0;
float rightArmForce=0;

int getLeftArm(){
	return SensorValue[potLeft]-leftArmBase;
}

int getRightArm(){
	return SensorValue[potRight]-rightArmBase;
}

//set motor
void leftArmDir(float dir){
		motor[bottomLeftArm] = dir*fullPower;
		motor[topLeftArm] = dir*fullPower;
}

//set motor
void rightArmDir(float dir){
		motor[bottomRightArm] = dir*fullPower;
		motor[topRightArm] = dir*fullPower;
}

// Move the arm up or down. dir=1 for up, -1 for down
void armDirection(float dir){
	leftArmDir(dir);
	rightArmDir(dir);
}

//set motor
void intakeDir(float dir){
		motor[intake] = dir*fullPower;
}
void clawDir(float dir){
		motor[claw] = dir*fullPower;
}

void armRebalance(){
	int curLeft = getLeftArm();
	int curRight = getRightArm();



	const int fudge=50;//dead zone between arms
	const float balanceForceAdjust=0.00005;
	if (abs(curLeft-curRight)>fudge){
		  float fact = abs(curLeft-curRight)/fudge;
			if (curLeft<curRight){
					leftArmForce += fact*balanceForceAdjust;
					rightArmForce -= fact*balanceForceAdjust;
					//rightArmForce = 0;
			} else {
			    //leftArmForce = 0;
					leftArmForce -= fact*balanceForceAdjust;
					rightArmForce += fact*balanceForceAdjust;
			}
	}

	else {
		float adj = (armForceAdjust(prevLeftArm, curLeft) + armForceAdjust(prevRightArm, curRight))/2;
		leftArmForce += adj;
		rightArmForce += adj;

	}

	leftArmForce =MIN(1.0, MAX(leftArmForce,-1));
	rightArmForce =MIN(1.0, MAX(rightArmForce,-1));

	leftArmDir(leftArmForce);
	rightArmDir(rightArmForce);


}

void resetArmForceAdjusts(){
	leftArmForce = 0;
	rightArmForce = 0;
}

void autonomous(){
	//MOVEMENT CODE
	int height = 2;
	int red = -1;
	//go forward till encoder hits
	motor[backLeft] = 127;
	motor[backRight] = 127;
	motor[frontLeft] = 127;
	motor[frontRight] = 127;
	wait1Msec(750);
	//stops robot
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	//picks up cube
	motor[intake] = 127;
	wait1Msec(500);
	motor[intake] = 0;
	//turns left toward pole
	motor[backLeft] =   red*100;
	motor[backRight] =   red*-100;
	motor[frontLeft] =  red*100;
	motor[frontRight] =  red*-100;
	wait1Msec(400);
	//stops robot
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	//moves arm up till medium pole height
	while(SensorValue[potLeft] > 1000*height || SensorValue[potRight] > 1000*height){
		motor[topRightArm] = 127;
		motor[bottomLeftArm] = 127;
		motor[topLeftArm] = 127;
		motor[bottomRightArm] = 127;
	}//EDIT POT VALUES BEFORE TESTING

	//stops robot
	motor[topRightArm] =  0;
	motor[bottomLeftArm] = 0;
	motor[topLeftArm] =  0;
	motor[bottomRightArm] =  0;

	//go forward toward pole
	motor[backLeft] = 127;
	motor[backRight] = 127;
	motor[frontLeft] = 127;
	motor[frontRight] = 127;
	wait1Msec(400);
	//stops robot
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;

	//drops off cube
	motor[intake] = -127;
	wait1Msec(700);
	// stops intake
	motor[intake] = 0;
}


task main()
{
		leftArmBase =  SensorValue[potLeft];
		rightArmBase = SensorValue[potRight];
		prevLeftArm = 0;
		prevRightArm = 0;

		while(true) {
		//Driver control with controller 1
		//Create deadzone for Channel 1
		if(abs(vexRT[Ch1]) > threshold) {
			chnl1 = vexRT[Ch1];
		}
		else {
			chnl1 = 0;
		}
		//Create deadzone for Channel 3
		if(abs(vexRT[Ch3]) > threshold) {
			chnl3 = vexRT[Ch3];
		}
		else {
			chnl3 = 0;
		}
		//driverDeadzone();

		//Joystick control for driver
		motor[frontRight] = chnl3 - chnl1;
		motor[backRight] = chnl3 - chnl1;
		motor[backLeft] = chnl3 + chnl1;
		motor[frontLeft] = chnl3 + chnl1;
		//driverControl();
			//======= Intake Ctrl
		if(vexRT[Btn6U] == 1) {//intake up
			intakeDir(1);
		} else if(vexRT[Btn5U] == 1) {//intake down
			intakeDir(-1);
		}
		else{//shut off intake
			intakeDir(0);
		}
		//7 is left
		//8 is right
		if(vexRT[Btn7U] == 1){
			leftArmDir(1);
		}else if(vexRT[Btn7D] == 1){
			leftArmDir(-1);
		}
		if(vexRT[Btn8U] == 1){
			rightArmDir(1);
		}else if(vexRT[Btn8D] == 1){
			rightArmDir(-1);
		}
			//======= Arm Ctrl
		if(vexRT[Btn6D] == 1) {//arm up
			resetArmForceAdjusts();
			armDirection(1);
		} else if(vexRT[Btn5D] == 1) {//arm down
			resetArmForceAdjusts();
		   armDirection(-0.6);
		}
		else if(automation){//automate rebalance
			armRebalance();
		}else{//shut off arm
			armDirection(0);
		}

		if(vexRT[Btn7L] == 1){
	  	clawDir(1);
	  	//open
		}else if(vexRT[Btn7R] == 1){
			clawDir(-1);
			//close
		}else{
			clawDir(0);
			//stop
		}

		if(vexRT[Btn8L] == 1){
	  	automation = true;
	  	//open
		}else if(vexRT[Btn8R] == 1){
			automation = false;
			//close
		}
		prevLeftArm = getLeftArm();
		prevRightArm = getRightArm();

	}
}
