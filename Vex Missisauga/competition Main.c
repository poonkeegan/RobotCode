#pragma config(Sensor, in1,    potRight,       sensorPotentiometer)
#pragma config(Sensor, in2,    potLeft,        sensorPotentiometer)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           bottomLeftArm, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           bottomRightArm, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           topLeftArm,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topRightArm,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


#define MAX(x,y) ((x)<(y) ? (y) : (x))
#define MIN(x,y) ((x)>(y) ? (y) : (x))

//Joystick variables
int chnl1 = 0, chnl3 = 0, threshold = 10;
//Drive variables
int fullPower = 127;
// Encoder values for the arms in the previous tick
int prevLeftArm = 806;
int prevRightArm = 248;
int leftArmBase;
int rightArmBase;

bool automation = false;
const float armForceAdjustConst =  1.0/100;
// How much we should change the force we are applying based on
// the potentiometer diffs
float armForceAdjust(int prev, int cur){
	return (prev-cur)*armForceAdjustConst;
}

float leftArmForce=0;
float rightArmForce=0;
int getLeftArm(){
	return SensorValue[potLeft]-leftArmBase;
}

int getRightArm(){
	return SensorValue[potRight]-rightArmBase;
}

//set motor
void leftArmDir(float dir){
		motor[bottomLeftArm] = dir*fullPower;
		motor[topLeftArm] = dir*fullPower;
}

//set motor
void rightArmDir(float dir){
		motor[bottomRightArm] = dir*fullPower;
		motor[topRightArm] = dir*fullPower;
}

// Move the arm up or down. dir=1 for up, -1 for down
void armDirection(float dir){
	leftArmDir(dir);
	rightArmDir(dir);
}

//set motor
void intakeDir(float dir){
		motor[intake] = dir*fullPower;
}
void clawDir(float dir){
		motor[claw] = dir*fullPower;
}

void armRebalance(){
	int curLeft = getLeftArm();
	int curRight = getRightArm();



	const int fudge=50;//dead zone between arms
	const float balanceForceAdjust=0.00005;
	if (abs(curLeft-curRight)>fudge){
		  float fact = abs(curLeft-curRight)/fudge;
			if (curLeft<curRight){
					leftArmForce += fact*balanceForceAdjust;
					rightArmForce -= fact*balanceForceAdjust;
					//rightArmForce = 0;
			} else {
			    //leftArmForce = 0;
					leftArmForce -= fact*balanceForceAdjust;
					rightArmForce += fact*balanceForceAdjust;
			}
	}

	else {
		float adj = (armForceAdjust(prevLeftArm, curLeft) + armForceAdjust(prevRightArm, curRight))/2;
		leftArmForce += adj;
		rightArmForce += adj;

	}

	leftArmForce =MIN(1.0, MAX(leftArmForce,-1));
	rightArmForce =MIN(1.0, MAX(rightArmForce,-1));

	leftArmDir(leftArmForce);
	rightArmDir(rightArmForce);


}

void resetArmForceAdjusts(){
	leftArmForce = 0;
	rightArmForce = 0;
}



void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
		leftArmBase =  SensorValue[potLeft];
		rightArmBase = SensorValue[potRight];
		prevLeftArm = 0;
		prevRightArm = 0;

		while(true) {
		//Driver control with controller 1
		//Create deadzone for Channel 1
		if(abs(vexRT[Ch1]) > threshold) {
			chnl1 = vexRT[Ch1];
		}
		else {
			chnl1 = 0;
		}
		//Create deadzone for Channel 3
		if(abs(vexRT[Ch3]) > threshold) {
			chnl3 = vexRT[Ch3];
		}
		else {
			chnl3 = 0;
		}
		//driverDeadzone();

		//Joystick control for driver
		motor[frontRight] = chnl3 - chnl1;
		motor[backRight] = chnl3 - chnl1;
		motor[backLeft] = chnl3 + chnl1;
		motor[frontLeft] = chnl3 + chnl1;
		//driverControl();
			//======= Intake Ctrl
		if(vexRT[Btn6U] == 1) {//intake up
			intakeDir(1);
		} else if(vexRT[Btn5U] == 1) {//intake down
			intakeDir(-1);
		}
		else{//shut off intake
			intakeDir(0);
		}
		//7 is left
		//8 is right
		if(vexRT[Btn7U] == 1){
			leftArmDir(1);
		}else if(vexRT[Btn7D] == 1){
			leftArmDir(-1);
		}
		if(vexRT[Btn8U] == 1){
			rightArmDir(1);
		}else if(vexRT[Btn8D] == 1){
			rightArmDir(-1);
		}
			//======= Arm Ctrl
		if(vexRT[Btn6D] == 1) {//arm up
			resetArmForceAdjusts();
			armDirection(1);
		} else if(vexRT[Btn5D] == 1) {//arm down
			resetArmForceAdjusts();
		   armDirection(-0.6);
		}
		else if(automation){//automate rebalance
			armRebalance();
		}else{//shut off arm
			armDirection(0);
		}


	 // if(vexRT[Btn8R] == 1){
	 // 	automation = !automation;
	 // }
		if(vexRT[Btn7L] == 1){
	  	clawDir(1);
	  	//open
		}else if(vexRT[Btn7R] == 1){
			clawDir(-1);
			//close
		}else{
			clawDir(0);
			//stop
		}
		if(vexRT[Btn8L] == 1){
	  	automation = true;
	  	//open
		}else if(vexRT[Btn8R] == 1){
			automation = false;
			//close
		}
		//motor[bottomRightArm] = -vexRT[Ch3Xmtr2];
		//motor[bottomLeftArm] = -vexRT[Ch3Xmtr2];
		//motor[topLeftArm] = -vexRT[Ch3Xmtr2];
		//motor[topRightArm] = -vexRT[Ch3Xmtr2];

		//while(SensorValue[potLeft] <= 2900 && SensorValue[potRight] <= 1700)
		prevLeftArm = getLeftArm();
		prevRightArm = getRightArm();

	}
}
